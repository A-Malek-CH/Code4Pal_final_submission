# -*- coding: utf-8 -*-
"""notebookf7f791b7f3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/scratchpad/notebookf7f791b7f3.1ae0a30b-66bf-4ba7-86f0-a64b7f2a6233.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250915/auto/storage/goog4_request%26X-Goog-Date%3D20250915T183341Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D6bf4fdd0e7bcd8d6a6c23506cda7a2e8a8b26f947c2420ce00679d5aba687214f9d4dbf1fca53ad64fd3d1268cfdfe3df75a51336bc2f3ba149162631073b9d64b3ff596ac35430ae5a6aa2d6a96a3b61f2a232977e1f4da9ce6d80b62f61ae7746b40581a74a565ef39711bd2c9674f7c1a73b8fd9bc05e671955ab1f6c397fbf6bf8ded7201016486858bc9dfa928775b9835d7da7588492a507bf760edd8992d874a8e697fd0035446ce148b6bcd1a8fc6b24b8f616eb94ab1dc3ae2cdf1dcd9a223add20af73c1153aae8898fae88974d23b61ef4b33b959c843b9c3fe89e97c287ac9f58997f95ca860dc92c15bfdb8eddc1fe65f6b29b3542730c196dd
"""

import numpy as np
import time
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer
import os
import json
import os
import random
from difflib import SequenceMatcher

CONV_FILE = "conversations.json"   # will store list of { "user": "...", "response": "...", "agent": "default"}
AGENTS_FILE = "agents.json"        # will store dict of agents keyed by name


class BulkChatBot:
    def __init__(self, default_agent="default"):
        self.default_agent = default_agent
        self.conversations = []
        self.agents = {}


        self._load_files()
        if self.default_agent not in self.agents:

            self.add_agent(self.default_agent, persona="Ø¯Ø§Ø¹Ù…ØŒØ§Ù„Ø±Ø­Ù…Ø©")

        print(" Ø¨ÙˆØª Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¬Ø§Ù‡Ø² â€“ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª:", len(self.conversations), "Ø§Ù„Ù€ agents:", len(self.agents))

    def _load_files(self):
        if os.path.exists(CONV_FILE):
            try:
                with open(CONV_FILE, "r", encoding="utf-8") as f:
                    self.conversations = json.load(f)
            except Exception:
                self.conversations = []
        if os.path.exists(AGENTS_FILE):
            try:
                with open(AGENTS_FILE, "r", encoding="utf-8") as f:
                    self.agents = json.load(f)
            except Exception:
                self.agents = {}

    def _save_files(self):
        with open(CONV_FILE, "w", encoding="utf-8") as f:
            json.dump(self.conversations, f, ensure_ascii=False, indent=2)
        with open(AGENTS_FILE, "w", encoding="utf-8") as f:
            json.dump(self.agents, f, ensure_ascii=False, indent=2)

    def add_agent(self, name, persona):
        """
        Add a new agent/persona.
        `name`: short id (e.g. "rahma", "therapist_v1")
        `persona`: text describing style (used for metadata)
        """
        self.agents[name] = {"name": name, "persona": persona}
        self._save_files()
        print(f" Agent '{name}' added.")

    def list_agents(self):
        return list(self.agents.keys())

    def add_entries(self, entries, agent=None, save=True):
        """
        Add many conversation entries at once.
        entries: list of tuples or dicts.
          - tuple/list format: (user_text, response_text)
          - dict format: {"user": "...", "response": "...", optional "agent": "..."}
        agent: default agent name to attach if entries don't include agent.
        """
        added = 0
        for e in entries:
            if isinstance(e, (list, tuple)) and len(e) >= 2:
                user_text, response_text = e[0].strip(), e[1].strip()
                ag = agent or self.default_agent
            elif isinstance(e, dict) and "user" in e and "response" in e:
                user_text, response_text = e["user"].strip(), e["response"].strip()
                ag = e.get("agent", agent or self.default_agent)
            else:
                continue
            self.conversations.append({"user": user_text, "response": response_text, "agent": ag})
            added += 1
        if save and added:
            self._save_files()
        print(f" Added {added} entries (agent={agent or self.default_agent}).")

    def load_from_csv(self, path, agent=None, delimiter="||"):
        """
        Load simple CSV/text lines where each line: user{delimiter}response
        e.g. "Ø£Ù†Ø§ Ø­Ø²ÙŠÙ†||ÙˆÙ„Ø§ ØªØ²Ø¹Ù„ØŒ Ø£Ù†Ø§ Ù…Ø¹Ùƒ"
        """
        if not os.path.exists(path):
            print("File not found:", path); return
        lines = open(path, "r", encoding="utf-8").read().splitlines()
        entries = []
        for ln in lines:
            if delimiter in ln:
                a, b = ln.split(delimiter, 1)
                entries.append((a.strip(), b.strip()))
        self.add_entries(entries, agent=agent)
        print(" Loaded from", path)


    @staticmethod
    def _similar(a, b):
        return SequenceMatcher(None, a, b).ratio()

    def find_best_response(self, user_text, agent=None, top_k=1, min_score=0.4):
        """
        Find best matching responses among stored conversations.
        Returns best response (string) or None.
        Uses simple fuzzy matching (SequenceMatcher). You can tune min_score.
        """
        agent = agent or self.default_agent
        best = []
        for entry in self.conversations:
            if entry.get("agent") != agent:
                continue
            score = self._similar(user_text, entry["user"])
            best.append((score, entry["response"], entry["user"]))
        if not best:
            return None
        best.sort(reverse=True, key=lambda x: x[0])
        if best[0][0] >= min_score:
            return best[0][1]  # return response
        return None

    def start_console_chat(self, agent=None):
        """
        Start console chat. Agent optional to choose persona.
        """
        agent = agent or self.default_agent
        persona = self.agents.get(agent, {}).get("persona", "")
        print(f"--- Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ '{agent}' ({persona}) ---")
        print('Ø§ÙƒØªØ¨ "agent:Ø§Ø³Ù…" Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø´Ø®ØµÙŠØ©ØŒ Ø§ÙƒØªØ¨ "exit" Ø£Ùˆ "Ø®Ù„Øµ" Ù„Ù„Ø®Ø±ÙˆØ¬.')

        while True:
            text = input("Ø£Ù†Øª >> ").strip()
            if not text:
                continue
            if text.lower() in ["Ø®Ù„Øµ", "exit", "Ù…Ø¹ Ø§Ù„Ø³Ù„Ø§Ù…Ø©"]:
                print("Ø§Ù„Ø¨ÙˆØª >> Ø¨Ø®Ø§Ø·Ø±Ùƒ ")
                break

            if text.startswith("agent:"):
                candidate = text.split("agent:",1)[1].strip()
                if candidate in self.agents:
                    agent = candidate
                    print(f" ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„Ù„Ø´Ø®ØµÙŠØ© '{agent}'")
                else:
                    print("Ø§Ù„Ø´Ø®ØµÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©. Ø§Ù„Ù…ØªØ§Ø­Ø©:", self.list_agents())
                continue

            resp = self.find_best_response(text, agent=agent, min_score=0.45)
            if resp:
                print("Ø§Ù„Ø¨ÙˆØª >>", resp)
            else:

                fallback = [
                    "Ø£Ù†Ø§ Ø³Ø§Ù…Ø¹Ùƒ ğŸ¤ØŒ ÙƒÙ…Ù„ ÙƒÙ„Ø§Ù…Ùƒ Ù„Ùˆ Ø­Ø§Ø¨Ø¨.",
                    "ÙˆÙ„Ø§ ÙŠÙ‡Ù…ÙƒØŒ Ø¥Ø­ÙƒÙŠÙ„ÙŠ Ø£ÙƒØ«Ø± Ù„Ùˆ Ø¨ØªØ±ØªØ§Ø­.",
                    "Ù…Ø¹Ùƒ Ø¯Ø§ÙŠÙ…Ù‹Ø§ØŒ Ø§Ø­ÙƒÙŠÙ„ÙŠ Ø´Ù†Ùˆ Ù…Ø¶Ø§ÙŠÙ‚Ùƒ.",
                    "Ø¢Ù‡ØŒ Ù‡Ø§Ù„Ø´ÙŠ ØµØ¹Ø¨.. Ø¨Ø³ Ø¥Ù†Øª Ù‚ÙˆÙŠ."
                ]
                print("Ø§Ù„Ø¨ÙˆØª >>", random.choice(fallback))


    def stats(self):
        by_agent = {}
        for c in self.conversations:
            a = c.get("agent", self.default_agent)
            by_agent[a] = by_agent.get(a, 0) + 1
        return {"total_conversations": len(self.conversations), "agents": list(self.agents.keys()), "counts": by_agent}



if __name__ == "__main__":
    bot = BulkChatBot()


    bulk = [
        ("Ø£Ù†Ø§ Ø®Ø§ÙŠÙ", "Ø·Ø¨ÙŠØ¹ÙŠ ØªØ­Ø³ Ø¨Ø§Ù„Ø®ÙˆÙØŒ Ø¨Ø¯Ù†Ø§ Ù†Ø·Ù…Ù† Ø´ÙˆÙŠ. Ø§Ø­ÙƒÙŠÙ„ÙŠ Ø§Ù„Ø³Ø¨Ø¨ØŸ"),
        ("Ø£Ù†Ø§ ØªØ¹Ø¨Ø§Ù†", "Ø§Ø±ØªØ§Ø­ÙŠ Ø´ÙˆÙŠ ÙˆØ®Ù„ÙŠ Ø¨Ø§Ù„Ùƒ Ø¨Ù†ÙØ³ÙƒØŒ Ø´Ùˆ Ø³Ø¨Ø¨ Ø§Ù„ØªØ¹Ø¨ØŸ"),
        ("Ø£Ù†Ø§ Ø¬Ø§Ø¦Ø¹", "Ø±ØºÙ… Ø§Ù„Ø¸Ø±ÙˆÙØŒ Ø­Ø§ÙˆÙ„ ØªØ£Ù…ÙˆÙ† Ø­Ø§Ø¬Ø© Ø¨Ø³ÙŠØ·Ø© Ù„Ùˆ ØªÙ‚Ø¯Ø±. Ø±Ø¨ÙŠ Ù…Ø¹Ùƒ."),

    ]
    bot.add_entries(bulk, agent="default")


    bot.add_agent("rahma_support", "Ø±Ø­Ù…Ø© â€“ ØµÙˆØª Ø­Ù†ÙˆÙ†ØŒ Ø¯Ø§ÙØ¦ØŒ ÙŠÙˆØ§Ø³ÙŠ ÙˆÙŠØ¹Ø·ÙŠ Ø®Ø·ÙˆØ§Øª Ø¨Ø³ÙŠØ·Ø©")


    bot.start_console_chat()